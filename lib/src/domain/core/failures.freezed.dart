// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res, ValueFailure<T>>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res, $Val extends ValueFailure<T>>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmptyCopyWith<T, $Res> {
  factory _$$EmptyCopyWith(_$Empty<T> value, $Res Function(_$Empty<T>) then) =
      __$$EmptyCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$EmptyCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$Empty<T>>
    implements _$$EmptyCopyWith<T, $Res> {
  __$$EmptyCopyWithImpl(_$Empty<T> _value, $Res Function(_$Empty<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$Empty<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$Empty<T> implements Empty<T> {
  const _$Empty({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Empty<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmptyCopyWith<T, _$Empty<T>> get copyWith =>
      __$$EmptyCopyWithImpl<T, _$Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return empty?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty({required final T failedValue}) = _$Empty<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$EmptyCopyWith<T, _$Empty<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidValueCopyWith<T, $Res> {
  factory _$$InvalidValueCopyWith(
          _$InvalidValue<T> value, $Res Function(_$InvalidValue<T>) then) =
      __$$InvalidValueCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidValueCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidValue<T>>
    implements _$$InvalidValueCopyWith<T, $Res> {
  __$$InvalidValueCopyWithImpl(
      _$InvalidValue<T> _value, $Res Function(_$InvalidValue<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidValue<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidValue<T> implements InvalidValue<T> {
  const _$InvalidValue({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidValue(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidValue<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidValueCopyWith<T, _$InvalidValue<T>> get copyWith =>
      __$$InvalidValueCopyWithImpl<T, _$InvalidValue<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidValue(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidValue?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidValue != null) {
      return invalidValue(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidValue != null) {
      return invalidValue(this);
    }
    return orElse();
  }
}

abstract class InvalidValue<T> implements ValueFailure<T> {
  const factory InvalidValue({required final T failedValue}) =
      _$InvalidValue<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidValueCopyWith<T, _$InvalidValue<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidMessageTypeCopyWith<T, $Res> {
  factory _$$InvalidMessageTypeCopyWith(_$InvalidMessageType<T> value,
          $Res Function(_$InvalidMessageType<T>) then) =
      __$$InvalidMessageTypeCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$InvalidMessageTypeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidMessageType<T>>
    implements _$$InvalidMessageTypeCopyWith<T, $Res> {
  __$$InvalidMessageTypeCopyWithImpl(_$InvalidMessageType<T> _value,
      $Res Function(_$InvalidMessageType<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidMessageType<T> implements InvalidMessageType<T> {
  const _$InvalidMessageType();

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidMessageType()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidMessageType<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidMessageType();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidMessageType?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidMessageType != null) {
      return invalidMessageType();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidMessageType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidMessageType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidMessageType != null) {
      return invalidMessageType(this);
    }
    return orElse();
  }
}

abstract class InvalidMessageType<T> implements ValueFailure<T> {
  const factory InvalidMessageType() = _$InvalidMessageType<T>;
}

/// @nodoc
abstract class _$$InvalidIntValueCopyWith<T, $Res> {
  factory _$$InvalidIntValueCopyWith(_$InvalidIntValue<T> value,
          $Res Function(_$InvalidIntValue<T>) then) =
      __$$InvalidIntValueCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidIntValueCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidIntValue<T>>
    implements _$$InvalidIntValueCopyWith<T, $Res> {
  __$$InvalidIntValueCopyWithImpl(
      _$InvalidIntValue<T> _value, $Res Function(_$InvalidIntValue<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidIntValue<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidIntValue<T> implements InvalidIntValue<T> {
  const _$InvalidIntValue({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidIntValue(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidIntValue<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidIntValueCopyWith<T, _$InvalidIntValue<T>> get copyWith =>
      __$$InvalidIntValueCopyWithImpl<T, _$InvalidIntValue<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidIntValue(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidIntValue?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidIntValue != null) {
      return invalidIntValue(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidIntValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidIntValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidIntValue != null) {
      return invalidIntValue(this);
    }
    return orElse();
  }
}

abstract class InvalidIntValue<T> implements ValueFailure<T> {
  const factory InvalidIntValue({required final T failedValue}) =
      _$InvalidIntValue<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidIntValueCopyWith<T, _$InvalidIntValue<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidUserIDCopyWith<T, $Res> {
  factory _$$InvalidUserIDCopyWith(
          _$InvalidUserID<T> value, $Res Function(_$InvalidUserID<T>) then) =
      __$$InvalidUserIDCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidUserIDCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidUserID<T>>
    implements _$$InvalidUserIDCopyWith<T, $Res> {
  __$$InvalidUserIDCopyWithImpl(
      _$InvalidUserID<T> _value, $Res Function(_$InvalidUserID<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidUserID<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidUserID<T> implements InvalidUserID<T> {
  const _$InvalidUserID({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUserID(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidUserID<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidUserIDCopyWith<T, _$InvalidUserID<T>> get copyWith =>
      __$$InvalidUserIDCopyWithImpl<T, _$InvalidUserID<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidUserID(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidUserID?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidUserID != null) {
      return invalidUserID(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidUserID(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidUserID?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidUserID != null) {
      return invalidUserID(this);
    }
    return orElse();
  }
}

abstract class InvalidUserID<T> implements ValueFailure<T> {
  const factory InvalidUserID({required final T failedValue}) =
      _$InvalidUserID<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidUserIDCopyWith<T, _$InvalidUserID<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDateTimeCopyWith<T, $Res> {
  factory _$$InvalidDateTimeCopyWith(_$InvalidDateTime<T> value,
          $Res Function(_$InvalidDateTime<T>) then) =
      __$$InvalidDateTimeCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidDateTimeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidDateTime<T>>
    implements _$$InvalidDateTimeCopyWith<T, $Res> {
  __$$InvalidDateTimeCopyWithImpl(
      _$InvalidDateTime<T> _value, $Res Function(_$InvalidDateTime<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidDateTime<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidDateTime<T> implements InvalidDateTime<T> {
  const _$InvalidDateTime({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDateTime(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDateTime<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDateTimeCopyWith<T, _$InvalidDateTime<T>> get copyWith =>
      __$$InvalidDateTimeCopyWithImpl<T, _$InvalidDateTime<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidDateTime(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidDateTime?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidDateTime != null) {
      return invalidDateTime(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidDateTime != null) {
      return invalidDateTime(this);
    }
    return orElse();
  }
}

abstract class InvalidDateTime<T> implements ValueFailure<T> {
  const factory InvalidDateTime({required final T failedValue}) =
      _$InvalidDateTime<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidDateTimeCopyWith<T, _$InvalidDateTime<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidRangeCopyWith<T, $Res> {
  factory _$$InvalidRangeCopyWith(
          _$InvalidRange<T> value, $Res Function(_$InvalidRange<T>) then) =
      __$$InvalidRangeCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, int min, int max});
}

/// @nodoc
class __$$InvalidRangeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidRange<T>>
    implements _$$InvalidRangeCopyWith<T, $Res> {
  __$$InvalidRangeCopyWithImpl(
      _$InvalidRange<T> _value, $Res Function(_$InvalidRange<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = null,
    Object? max = null,
  }) {
    return _then(_$InvalidRange<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$InvalidRange<T> implements InvalidRange<T> {
  const _$InvalidRange(
      {required this.failedValue, required this.min, required this.max});

  @override
  final T failedValue;
  @override
  final int min;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidRange(failedValue: $failedValue, min: $min, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidRange<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.min, min) || other.min == min) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), min, max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidRangeCopyWith<T, _$InvalidRange<T>> get copyWith =>
      __$$InvalidRangeCopyWithImpl<T, _$InvalidRange<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidRange(failedValue, min, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidRange?.call(failedValue, min, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidRange != null) {
      return invalidRange(failedValue, min, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidRange != null) {
      return invalidRange(this);
    }
    return orElse();
  }
}

abstract class InvalidRange<T> implements ValueFailure<T> {
  const factory InvalidRange(
      {required final T failedValue,
      required final int min,
      required final int max}) = _$InvalidRange<T>;

  T get failedValue;
  int get min;
  int get max;
  @JsonKey(ignore: true)
  _$$InvalidRangeCopyWith<T, _$InvalidRange<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidDoubleRangeCopyWith<T, $Res> {
  factory _$$InvalidDoubleRangeCopyWith(_$InvalidDoubleRange<T> value,
          $Res Function(_$InvalidDoubleRange<T>) then) =
      __$$InvalidDoubleRangeCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, double min, double max});
}

/// @nodoc
class __$$InvalidDoubleRangeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidDoubleRange<T>>
    implements _$$InvalidDoubleRangeCopyWith<T, $Res> {
  __$$InvalidDoubleRangeCopyWithImpl(_$InvalidDoubleRange<T> _value,
      $Res Function(_$InvalidDoubleRange<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = null,
    Object? max = null,
  }) {
    return _then(_$InvalidDoubleRange<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$InvalidDoubleRange<T> implements InvalidDoubleRange<T> {
  const _$InvalidDoubleRange(
      {required this.failedValue, required this.min, required this.max});

  @override
  final T failedValue;
  @override
  final double min;
  @override
  final double max;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDoubleRange(failedValue: $failedValue, min: $min, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidDoubleRange<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.min, min) || other.min == min) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), min, max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidDoubleRangeCopyWith<T, _$InvalidDoubleRange<T>> get copyWith =>
      __$$InvalidDoubleRangeCopyWithImpl<T, _$InvalidDoubleRange<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidDoubleRange(failedValue, min, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidDoubleRange?.call(failedValue, min, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidDoubleRange != null) {
      return invalidDoubleRange(failedValue, min, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidDoubleRange(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidDoubleRange?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidDoubleRange != null) {
      return invalidDoubleRange(this);
    }
    return orElse();
  }
}

abstract class InvalidDoubleRange<T> implements ValueFailure<T> {
  const factory InvalidDoubleRange(
      {required final T failedValue,
      required final double min,
      required final double max}) = _$InvalidDoubleRange<T>;

  T get failedValue;
  double get min;
  double get max;
  @JsonKey(ignore: true)
  _$$InvalidDoubleRangeCopyWith<T, _$InvalidDoubleRange<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListTooLongCopyWith<T, $Res> {
  factory _$$ListTooLongCopyWith(
          _$ListTooLong<T> value, $Res Function(_$ListTooLong<T>) then) =
      __$$ListTooLongCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, int max});
}

/// @nodoc
class __$$ListTooLongCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$ListTooLong<T>>
    implements _$$ListTooLongCopyWith<T, $Res> {
  __$$ListTooLongCopyWithImpl(
      _$ListTooLong<T> _value, $Res Function(_$ListTooLong<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = null,
  }) {
    return _then(_$ListTooLong<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ListTooLong<T> implements ListTooLong<T> {
  const _$ListTooLong({required this.failedValue, required this.max});

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.listTooLong(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListTooLong<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListTooLongCopyWith<T, _$ListTooLong<T>> get copyWith =>
      __$$ListTooLongCopyWithImpl<T, _$ListTooLong<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return listTooLong(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return listTooLong?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return listTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return listTooLong?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(this);
    }
    return orElse();
  }
}

abstract class ListTooLong<T> implements ValueFailure<T> {
  const factory ListTooLong(
      {required final T failedValue,
      required final int max}) = _$ListTooLong<T>;

  T get failedValue;
  int get max;
  @JsonKey(ignore: true)
  _$$ListTooLongCopyWith<T, _$ListTooLong<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidVINCopyWith<T, $Res> {
  factory _$$InvalidVINCopyWith(
          _$InvalidVIN<T> value, $Res Function(_$InvalidVIN<T>) then) =
      __$$InvalidVINCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidVINCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidVIN<T>>
    implements _$$InvalidVINCopyWith<T, $Res> {
  __$$InvalidVINCopyWithImpl(
      _$InvalidVIN<T> _value, $Res Function(_$InvalidVIN<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidVIN<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidVIN<T> implements InvalidVIN<T> {
  const _$InvalidVIN({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidVIN(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidVIN<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidVINCopyWith<T, _$InvalidVIN<T>> get copyWith =>
      __$$InvalidVINCopyWithImpl<T, _$InvalidVIN<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidVIN(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidVIN?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidVIN != null) {
      return invalidVIN(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidVIN(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidVIN?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidVIN != null) {
      return invalidVIN(this);
    }
    return orElse();
  }
}

abstract class InvalidVIN<T> implements ValueFailure<T> {
  const factory InvalidVIN({required final T failedValue}) = _$InvalidVIN<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidVINCopyWith<T, _$InvalidVIN<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidWMICopyWith<T, $Res> {
  factory _$$InvalidWMICopyWith(
          _$InvalidWMI<T> value, $Res Function(_$InvalidWMI<T>) then) =
      __$$InvalidWMICopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidWMICopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidWMI<T>>
    implements _$$InvalidWMICopyWith<T, $Res> {
  __$$InvalidWMICopyWithImpl(
      _$InvalidWMI<T> _value, $Res Function(_$InvalidWMI<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidWMI<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidWMI<T> implements InvalidWMI<T> {
  const _$InvalidWMI({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidWMI(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidWMI<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidWMICopyWith<T, _$InvalidWMI<T>> get copyWith =>
      __$$InvalidWMICopyWithImpl<T, _$InvalidWMI<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidWMI(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidWMI?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidWMI != null) {
      return invalidWMI(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidWMI(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidWMI?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidWMI != null) {
      return invalidWMI(this);
    }
    return orElse();
  }
}

abstract class InvalidWMI<T> implements ValueFailure<T> {
  const factory InvalidWMI({required final T failedValue}) = _$InvalidWMI<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidWMICopyWith<T, _$InvalidWMI<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidUOMCopyWith<T, $Res> {
  factory _$$InvalidUOMCopyWith(
          _$InvalidUOM<T> value, $Res Function(_$InvalidUOM<T>) then) =
      __$$InvalidUOMCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidUOMCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidUOM<T>>
    implements _$$InvalidUOMCopyWith<T, $Res> {
  __$$InvalidUOMCopyWithImpl(
      _$InvalidUOM<T> _value, $Res Function(_$InvalidUOM<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidUOM<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidUOM<T> implements InvalidUOM<T> {
  const _$InvalidUOM({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUOM(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidUOM<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidUOMCopyWith<T, _$InvalidUOM<T>> get copyWith =>
      __$$InvalidUOMCopyWithImpl<T, _$InvalidUOM<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidUOM(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidUOM?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidUOM != null) {
      return invalidUOM(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidUOM(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidUOM?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidUOM != null) {
      return invalidUOM(this);
    }
    return orElse();
  }
}

abstract class InvalidUOM<T> implements ValueFailure<T> {
  const factory InvalidUOM({required final T failedValue}) = _$InvalidUOM<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidUOMCopyWith<T, _$InvalidUOM<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidSiteCopyWith<T, $Res> {
  factory _$$InvalidSiteCopyWith(
          _$InvalidSite<T> value, $Res Function(_$InvalidSite<T>) then) =
      __$$InvalidSiteCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue});
}

/// @nodoc
class __$$InvalidSiteCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$InvalidSite<T>>
    implements _$$InvalidSiteCopyWith<T, $Res> {
  __$$InvalidSiteCopyWithImpl(
      _$InvalidSite<T> _value, $Res Function(_$InvalidSite<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidSite<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidSite<T> implements InvalidSite<T> {
  const _$InvalidSite({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidSite(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidSite<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InvalidSiteCopyWith<T, _$InvalidSite<T>> get copyWith =>
      __$$InvalidSiteCopyWithImpl<T, _$InvalidSite<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return invalidSite(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return invalidSite?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidSite != null) {
      return invalidSite(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return invalidSite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return invalidSite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (invalidSite != null) {
      return invalidSite(this);
    }
    return orElse();
  }
}

abstract class InvalidSite<T> implements ValueFailure<T> {
  const factory InvalidSite({required final T failedValue}) = _$InvalidSite<T>;

  T get failedValue;
  @JsonKey(ignore: true)
  _$$InvalidSiteCopyWith<T, _$InvalidSite<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExceedingLengthCopyWith<T, $Res> {
  factory _$$ExceedingLengthCopyWith(_$ExceedingLength<T> value,
          $Res Function(_$ExceedingLength<T>) then) =
      __$$ExceedingLengthCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T failedValue, int max});
}

/// @nodoc
class __$$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$ExceedingLength<T>>
    implements _$$ExceedingLengthCopyWith<T, $Res> {
  __$$ExceedingLengthCopyWithImpl(
      _$ExceedingLength<T> _value, $Res Function(_$ExceedingLength<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = null,
  }) {
    return _then(_$ExceedingLength<T>(
      failedValue: freezed == failedValue
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength({required this.failedValue, required this.max});

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExceedingLength<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue), max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExceedingLengthCopyWith<T, _$ExceedingLength<T>> get copyWith =>
      __$$ExceedingLengthCopyWithImpl<T, _$ExceedingLength<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return exceedingLength?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return exceedingLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength(
      {required final T failedValue,
      required final int max}) = _$ExceedingLength<T>;

  T get failedValue;
  int get max;
  @JsonKey(ignore: true)
  _$$ExceedingLengthCopyWith<T, _$ExceedingLength<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_DatabaseErrorCopyWith<T, $Res> {
  factory _$$_DatabaseErrorCopyWith(
          _$_DatabaseError<T> value, $Res Function(_$_DatabaseError<T>) then) =
      __$$_DatabaseErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({dynamic err});
}

/// @nodoc
class __$$_DatabaseErrorCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res, _$_DatabaseError<T>>
    implements _$$_DatabaseErrorCopyWith<T, $Res> {
  __$$_DatabaseErrorCopyWithImpl(
      _$_DatabaseError<T> _value, $Res Function(_$_DatabaseError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? err = freezed,
  }) {
    return _then(_$_DatabaseError<T>(
      err: freezed == err
          ? _value.err
          : err // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$_DatabaseError<T> implements _DatabaseError<T> {
  const _$_DatabaseError({required this.err});

  @override
  final dynamic err;

  @override
  String toString() {
    return 'ValueFailure<$T>.databaseError(err: $err)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DatabaseError<T> &&
            const DeepCollectionEquality().equals(other.err, err));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(err));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DatabaseErrorCopyWith<T, _$_DatabaseError<T>> get copyWith =>
      __$$_DatabaseErrorCopyWithImpl<T, _$_DatabaseError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) empty,
    required TResult Function(T failedValue) invalidValue,
    required TResult Function() invalidMessageType,
    required TResult Function(T failedValue) invalidIntValue,
    required TResult Function(T failedValue) invalidUserID,
    required TResult Function(T failedValue) invalidDateTime,
    required TResult Function(T failedValue, int min, int max) invalidRange,
    required TResult Function(T failedValue, double min, double max)
        invalidDoubleRange,
    required TResult Function(T failedValue, int max) listTooLong,
    required TResult Function(T failedValue) invalidVIN,
    required TResult Function(T failedValue) invalidWMI,
    required TResult Function(T failedValue) invalidUOM,
    required TResult Function(T failedValue) invalidSite,
    required TResult Function(T failedValue, int max) exceedingLength,
    required TResult Function(dynamic err) databaseError,
  }) {
    return databaseError(err);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T failedValue)? empty,
    TResult? Function(T failedValue)? invalidValue,
    TResult? Function()? invalidMessageType,
    TResult? Function(T failedValue)? invalidIntValue,
    TResult? Function(T failedValue)? invalidUserID,
    TResult? Function(T failedValue)? invalidDateTime,
    TResult? Function(T failedValue, int min, int max)? invalidRange,
    TResult? Function(T failedValue, double min, double max)?
        invalidDoubleRange,
    TResult? Function(T failedValue, int max)? listTooLong,
    TResult? Function(T failedValue)? invalidVIN,
    TResult? Function(T failedValue)? invalidWMI,
    TResult? Function(T failedValue)? invalidUOM,
    TResult? Function(T failedValue)? invalidSite,
    TResult? Function(T failedValue, int max)? exceedingLength,
    TResult? Function(dynamic err)? databaseError,
  }) {
    return databaseError?.call(err);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? empty,
    TResult Function(T failedValue)? invalidValue,
    TResult Function()? invalidMessageType,
    TResult Function(T failedValue)? invalidIntValue,
    TResult Function(T failedValue)? invalidUserID,
    TResult Function(T failedValue)? invalidDateTime,
    TResult Function(T failedValue, int min, int max)? invalidRange,
    TResult Function(T failedValue, double min, double max)? invalidDoubleRange,
    TResult Function(T failedValue, int max)? listTooLong,
    TResult Function(T failedValue)? invalidVIN,
    TResult Function(T failedValue)? invalidWMI,
    TResult Function(T failedValue)? invalidUOM,
    TResult Function(T failedValue)? invalidSite,
    TResult Function(T failedValue, int max)? exceedingLength,
    TResult Function(dynamic err)? databaseError,
    required TResult orElse(),
  }) {
    if (databaseError != null) {
      return databaseError(err);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Empty<T> value) empty,
    required TResult Function(InvalidValue<T> value) invalidValue,
    required TResult Function(InvalidMessageType<T> value) invalidMessageType,
    required TResult Function(InvalidIntValue<T> value) invalidIntValue,
    required TResult Function(InvalidUserID<T> value) invalidUserID,
    required TResult Function(InvalidDateTime<T> value) invalidDateTime,
    required TResult Function(InvalidRange<T> value) invalidRange,
    required TResult Function(InvalidDoubleRange<T> value) invalidDoubleRange,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(InvalidVIN<T> value) invalidVIN,
    required TResult Function(InvalidWMI<T> value) invalidWMI,
    required TResult Function(InvalidUOM<T> value) invalidUOM,
    required TResult Function(InvalidSite<T> value) invalidSite,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(_DatabaseError<T> value) databaseError,
  }) {
    return databaseError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Empty<T> value)? empty,
    TResult? Function(InvalidValue<T> value)? invalidValue,
    TResult? Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult? Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult? Function(InvalidUserID<T> value)? invalidUserID,
    TResult? Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult? Function(InvalidRange<T> value)? invalidRange,
    TResult? Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult? Function(ListTooLong<T> value)? listTooLong,
    TResult? Function(InvalidVIN<T> value)? invalidVIN,
    TResult? Function(InvalidWMI<T> value)? invalidWMI,
    TResult? Function(InvalidUOM<T> value)? invalidUOM,
    TResult? Function(InvalidSite<T> value)? invalidSite,
    TResult? Function(ExceedingLength<T> value)? exceedingLength,
    TResult? Function(_DatabaseError<T> value)? databaseError,
  }) {
    return databaseError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Empty<T> value)? empty,
    TResult Function(InvalidValue<T> value)? invalidValue,
    TResult Function(InvalidMessageType<T> value)? invalidMessageType,
    TResult Function(InvalidIntValue<T> value)? invalidIntValue,
    TResult Function(InvalidUserID<T> value)? invalidUserID,
    TResult Function(InvalidDateTime<T> value)? invalidDateTime,
    TResult Function(InvalidRange<T> value)? invalidRange,
    TResult Function(InvalidDoubleRange<T> value)? invalidDoubleRange,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(InvalidVIN<T> value)? invalidVIN,
    TResult Function(InvalidWMI<T> value)? invalidWMI,
    TResult Function(InvalidUOM<T> value)? invalidUOM,
    TResult Function(InvalidSite<T> value)? invalidSite,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(_DatabaseError<T> value)? databaseError,
    required TResult orElse(),
  }) {
    if (databaseError != null) {
      return databaseError(this);
    }
    return orElse();
  }
}

abstract class _DatabaseError<T> implements ValueFailure<T> {
  const factory _DatabaseError({required final dynamic err}) =
      _$_DatabaseError<T>;

  dynamic get err;
  @JsonKey(ignore: true)
  _$$_DatabaseErrorCopyWith<T, _$_DatabaseError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
